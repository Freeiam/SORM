; ╔════════════════════════════════════════════════════════════════════════════╗
; ║  Файл:        RingBuff.ASM                                                 ║
; ║  Программист: Тоневицкий Ю.Д.                                              ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Использует:  RingBuff.DAT                                                 ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Назначение:  Объект Кольцевой Буфер является предназначен для хранения    ║
; ║               как байт так и пакетов. Доступ к данным осуществляется по    ║
; ║               алгоритму FIFO.                                              ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Содержит: 1. RB_Init     - инициализация буферов                          ║
; ║            2. RB_BPut     - запись цепочки байт                            ║
; ║            3. RB_BPutAL   - запись байта из AL                             ║
; ║            4. RB_BPutAX   - запись слова из AX                             ║
; ║            5. RB_BPutEAX  - запись двойного слова из EAX                   ║
; ║            6. RB_BGet     - чтение цепочки байт                            ║
; ║            7. RB_BGetAL   - чтение байта в AL                              ║
; ║            8. RB_BGetAX   - чтение слова в AX                              ║
; ║            9. RB_BGetEAX  - чтение двойного слова в EAX                    ║
; ║           10. RB_MPut     - запись сообщения (пакета)                      ║
; ║           11. RB_MGet     - чтение сообщения (пакета)                      ║
; ║           12. RB_MAllGet  - чтение сообщения со словом длины               ║
; ║           13. RB_MCopy    - копирование сообщения из А в Б без очистки А   ║
; ║           14. RB_MMove    - перенос сообщения из А в Б с очисткой А        ║
; ║           15. RB_MCommInfo- информация для коммутатора сообщений           ║
; ║           16. RB_MLen     - возвращает длину считываемого пакета           ║
; ║           17. RB_Clear    - очистка буфера от данных                       ║
; ║           18. RB_OFCnt    - чтение счётчика переполнений (можно с очисткой)║
; ║           19. RB_Prms     - чтение состояния (параметров) буфера           ║
; ╚════════════════════════════════════════════════════════════════════════════╝

; !!! Сегмент под буфера должен иметь размер, позволяющий разместить все  !!!
; !!! заголовки буферов (каждый по 32 байта) + всю используемую буферами  !!!
; !!! память, округлённую вверх до ближайшего числа кратного 4.           !!!
; !!! Если старший бит DD длины создаваемого буфера = 1  -  это пакетный  !!!
; !!! буфер, иначе байтовый буфер                                         !!!

; --- иницивлизация набора буферов --------------------------------------------
; вход:  ecx    - число создаваемых буферов
;        ds:esi - указатель на цепочку DD, содержащих длины создаваемых буферов
;        es     - селектор сегмента, от начала которого будут размещены буфера
; выход: edi    - указатель на байт, следующий за последним размещённым

; !!!  Пример описания создаваемых буферов:                               !!!
; !!!  My_Buff  DD  123, 456, _RBM + 789                                  !!!
; !!!  Если при вызове RB_Init записать в ds:esi SEG:OFFSET метки My_BUff !!!
; !!!  1. байтовый буфер размером 123 байта                               !!!
; !!!  2. байтовый буфер размером 456 байт                                !!!
; !!!  3. пакетный буфер размером 792 байта (789 округлено вверх до       !!!
; !!!     ближайшего кратного четырём                                     !!!

RB_Init         PROC
                push    eax
                push    ecx
                push    edx
                push    esi
                push    ebp
                cld

                mov     ebp, ecx        ; число создаваемых буферов
                shl     ebp, _RB_STRUC_SHL ; ук. на 1-й байт памяти: структуры занимают 32*ecx
                push    ebp             ; запомним его
                xor     edi, edi        ; начнём с начала сегмента
RBI_Loop:       lodsd                   ; читаем размер буфера
                btr     eax, 31         ; запоминаем старший бит (тип буфера) и сбрасываем его
                pushf
                jnc     SHORT RBI_0     ; байтовый буфер - ничего не делаем с длиной
                test    eax, 3          ; пакетный буфер - его длина кратна 4 ?
                jz      SHORT RBI_0     ; ДА - ничего не делаем с длиной
                add     eax, 4          ; \ округляем вверх до ближайшего
                and     eax, 0fffffffch ; / числа кратного 4
RBI_0:          stosd                   ; пишем размер буфера и
                mov     edx, eax        ; запоминаем размер
                xor     eax, eax        ;
                popf
                setc    al              ;
                stosd                   ; аттрибуты в соответствии с типом буфера
                xor     al, al          ;
                stosd                   ; счётчик переполнений
                stosd                   ; счётчик байт
                stosd                   ; счётчик сообщений
                mov     eax, ebp        ;
                stosd                   ; указатель записи
                stosd                   ; указатель чтения
                stosd                   ; указатель на используемую созданным буфером память
                add     ebp, edx        ; указатель на память следующего буфера
                loop    RBI_Loop
                pop     edi             ; указатель па первый байт используемой памяти
                mov     ecx, ebp        ; указатель на следующий после последнего байт
                sub     ecx, edi        ; ecx - надо разместить столько байт
                test    ecx, 3          ; число размещаемых байт кратно 4 ?
                jz      SHORT RBI_1     ; ДА -
                add     ecx, 4          ; НЕТ - чтобы округлить
RBI_1:          shr     ecx, 2          ; ecx - размер занимаемой памяти в двойных словах
                xor     eax, eax
                rep     stosd           ; очищаем используемую память

                pop     ebp
                pop     esi
                pop     edx
                pop     ecx
                pop     eax
                ret
RB_Init         ENDP

; --- запись цепочки байт в кольцевой буфер -----------------------------------
;     !! при попытке записать больше чем можно - ПРОСТО НИЧЕГО НЕ ПРОИСХОДИТ !!
; вход:  edx    - номер буфера, который собираемся использовать, в es
;        ecx    - число записываемых байт
;        ds:esi - указатель на первый записываемый байт
;        es     - селектор сегмента содержащего используемый буфер
; выход: edx    - количество реально записанных байт
;        ds:esi - указатель на байт, следующий за последним записанным
;
RB_BPut         PROC
                push    eax
                push    ebx
                push    ecx
                push    edi
                cld
                shl     edx, _RB_STRUC_SHL      ; указатель на управляющую структуру буфера
                mov     ebx, es:[edx].len       ; размер буфера
                mov     edi, ebx
                mov     eax, es:[edx].mem_ptr   ; НИЖНЯЯ граница используемой буфером памяти
                add     ebx, eax                ; ВЕРХНЯЯ граница используемой буфером памяти + 1
                sub     edi, es:[edx].byte_cntr ; свободно байт в буфере
                cmp     edi, ecx                ; есть место под ecx новых байт ?
                jae     SHORT RB_BP_1           ; ДА -
                mov     ecx, edi                ; НЕТ - запишем только сколько сможем
                inc     es:[edx].of_cntr        ; отметим возможное переполнение буфера
RB_BP_1:        push    ecx                     ; запомним число реально записываемых байт
                or      ecx, ecx                ; иль буфер полон, иль 0 байт мы пишем ?
                jz      SHORT RB_BP_3           ; ДА - запись невозможна !
                add     es:[edx].byte_cntr, ecx ; отметим что буфер потолстел
                mov     edi, es:[edx].wr_ptr    ; указатель на запись
RB_BP_Loop:     movsb
                cmp     edi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_BP_2           ; НЕТ -
                mov     edi, eax                ; ДА - указатель на начало используемой памяти
RB_BP_2:        loop    RB_BP_Loop
                mov     es:[edx].wr_ptr, edi    ; запомним новое положение указателя записи
RB_BP_3:        pop     edx                     ; вернём число реально записанных байт
                pop     edi
                pop     ecx
                pop     ebx
                pop     eax
                ret
RB_BPut         ENDP


; --- запись байта в кольцевой буфер ------------------------------------------
;     !! при попытке записать больше чем можно - ПРОСТО НИЧЕГО НЕ ПРОИСХОДИТ !!
; вход:  al     - записываемый байт
;        edx    - номер буфера, который собираемся использовать, в es
;        es     - селектор сегмента содержащего используемый буфер
; выход: edx    - количество реально записанных байт
;
RB_BPutAL       PROC
                push    ebx
                push    edi
                cld

                shl     edx, _RB_STRUC_SHL      ; указатель на управляющую структуру буфера
                mov     ebx, es:[edx].len       ; размер буфера
                cmp     ebx, es:[edx].byte_cntr ; можем принять хоть байт ?
                jbe     SHORT RB_BPAL_Full      ; НЕТ - буфер полон - на выход
                mov     edi, es:[edx].wr_ptr    ; указатель на запись
                stosb                           ; пишем байт
;;;                stos    BYTE PTR [edi]          ; пишем байт
                add     ebx, es:[edx].mem_ptr   ; верхняя граница используемой памяти + 1
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT   RB_BPAL_0       ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPAL_0:      mov     es:[edx].wr_ptr, edi    ; запомним новое значение указателя записи
                inc     es:[edx].byte_cntr
                mov     edx, 1                  ; записали 1 байт
                pop     edi
                pop     ebx
                ret

RB_BPAL_Full:   inc     es:[edx].of_cntr        ; отметим возможное переполнение буфера
                xor     edx, edx                ; ничего не записали
                pop     edi
                pop     ebx
                ret
RB_BPutAL       ENDP


; --- запись слова в кольцевой буфер ------------------------------------------
;     !! при попытке записать больше чем можно - ПРОСТО НИЧЕГО НЕ ПРОИСХОДИТ !!
; вход:  ax     - записываемый слово
;        edx    - номер буфера, который собираемся использовать, в es
;        es     - селектор сегмента содержащего используемый буфер
; выход: edx    - количество реально записанных байт
;
RB_BPutAX       PROC
                push    ebx
                push    edi
                push    ebp
                cld

                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                mov     ebx, es:[edx].len       ; размер буфера
                mov     ebp, ebx
                add     ebx, es:[edx].mem_ptr   ; верхняя граница используемой памяти + 1
                sub     ebp, es:[edx].byte_cntr ; свободно в буфере
                cmp     ebp, 2                  ; ещё 2 байта влезет ?
                jb      SHORT RB_BPAL_Full      ; НЕТ - буфер полон - на выход
                mov     edi, es:[edx].wr_ptr    ; указатель на запись
                stosb                           ; пишем мл. байт слова
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT   RB_BPAX_0       ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPAX_0:      xchg    al, ah
                stosb                           ; пишем ст. байт слова
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT   RB_BPAX_1       ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPAX_1:      mov     es:[edx].wr_ptr, edi    ; запомним новое значение указателя записи
                add     es:[edx].byte_cntr, 2
                mov     edx, 2                  ; записали 2 байта
                pop     ebp
                pop     edi
                pop     ebx
                ret
RB_BPutAX       ENDP


; --- запись двойного слова в кольцевой буфер ---------------------------------
;     !! при попытке записать больше чем можно - ПРОСТО НИЧЕГО НЕ ПРОИСХОДИТ !!
; вход:  eax    - записываемый двойное слово
;        edx    - номер буфера, который собираемся использовать, в es
;        es     - селектор сегмента содержащего используемый буфер
; выход: edx    - количество реально записанных байт
;
RB_BPutEAX      PROC
                push    ebx
                push    edi
                push    ebp
                cld

                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                mov     ebx, es:[edx].len       ; размер буфера
                mov     ebp, ebx
                add     ebx, es:[edx].mem_ptr   ; верхняя граница используемой памяти + 1
                sub     ebp, es:[edx].byte_cntr ; свободно в буфере
                cmp     ebp, 4                  ; ещё 4 байта влезет ?
                jb      RB_BPAL_Full            ; НЕТ - буфер полон - на выход
                mov     edi, es:[edx].wr_ptr    ; указатель на запись
                stosb                           ; пишем 1-й байт двойного слова
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT RB_BPEAX_0        ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPEAX_0:     shr     eax, 8
                stosb                           ; пишем 2-й байт двойного слова
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT RB_BPEAX_1        ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPEAX_1:     shr     eax, 8
                stosb                           ; пишем 3-й байт двойного слова
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT RB_BPEAX_2        ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPEAX_2:     shr     eax, 8
                stosb                           ; пишем 4-й байт двойного слова
                cmp     edi, ebx                ; вышли за верхнюю границу ?
                jb      SHORT RB_BPEAX_3        ; НЕТ -
                mov     edi, es:[edx].mem_ptr   ; ДА - ук. записи в начало используемой памяти
RB_BPEAX_3:     mov     es:[edx].wr_ptr, edi    ; запомним новое значение указателя записи
                add     es:[edx].byte_cntr, 4
                mov     edx, 4                  ; записали 4 байта
                pop     ebp
                pop     edi
                pop     ebx
                ret
RB_BPutEAX      ENDP


; --- чтение цепочки байт из кольцевого буфера --------------------------------
; !! при попытке прочитать больше чем есть - ПРОСТО ЧИТАЮТСЯ ТОЛЬКО ТЕ БАЙТЫ ЧТО ЕСТЬ В БУФЕРЕ !!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
;        ecx    - сколько байт хотим прочитать
;        es:edi - указатель на первый принимаемый байт
; выход: edx    - количество реально прочитанных байт
;        es:edi - указатель на байт, следующий после последнего принятого

RB_BGet         PROC
                jcxz    RB_BG_Empty             ; защита от чтения 0 байт
                shl     edx, _RB_STRUC_SHL      ; указатель на управляющую структуру буфера
                cmp     fs:[edx].byte_cntr, 0   ; в буфере есть что-нибудь ?
                jne     SHORT RB_BG_1           ; ДА - дальше
RB_BG_Empty:    xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_BG_1:        push    eax
                push    ebx
                push    ecx
                push    esi
                cld

                mov     ebx, fs:[edx].len       ; размер буфера
                mov     eax, fs:[edx].mem_ptr   ; НИЖНЯЯ граница используемой буфером памяти
                add     ebx, eax                ; ВЕРХНЯЯ граница используемой буфером памяти + 1
                cmp     ecx, fs:[edx].byte_cntr ; можем отдать сколько просят ?
                jbe     SHORT RB_BG_2           ; ДА -
                mov     ecx, fs:[edx].byte_cntr ; НЕТ - отдаём сколько есть
RB_BG_2:        push    ecx                     ; запомним сколько байт отдаём
                sub     fs:[edx].byte_cntr, ecx ; отметим что буфер похудел
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение
RB_BG_Loop:     movs    BYTE PTR [edi], BYTE PTR fs:[esi]
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_BG_3           ; НЕТ -
                mov     esi, eax                ; ДА - указатель на начало используемой памяти
RB_BG_3:        ;;;loop    RB_BG_Loop
                dec     ecx
                jnz     RB_BG_Loop
                mov     fs:[edx].rd_ptr, esi    ; запомним новое положение указателя чтения
                pop     edx                     ; на выходе число реально отданных байт

                pop     esi
                pop     ecx
                pop     ebx
                pop     eax
                ret
RB_BGet         ENDP


; --- чтение байта из кольцевого буфера в AL ----------------------------------
;     !! при попытке прочитать больше чем есть - ПРОСТО НИЧЕГО НЕ ЧИТАЕТСЯ  !!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
; выход: al     - прочитанный байт (если edx = 1)
;        edx    - количество реально прочитанных байт (т.е. 1 или 0)
;
RB_BGetAL       PROC
                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                cmp     fs:[edx].byte_cntr, 0   ; в буфере есть что-нибудь ?
                jne     SHORT RB_BGAL_0         ; ДА - дальше
RB_BGAL_Empty:  xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_BGAL_0:      push    ebx
                push    esi
                cld
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение
                lods    BYTE PTR fs:[esi]       ; получили байт из буфера
                mov     ebx, fs:[edx].mem_ptr
                add     ebx, fs:[edx].len       ; верхняя граница используемой памяти + 1
                cmp     esi, ebx                ; вышли за неё ?
                jb      SHORT RB_BGAL_1         ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGAL_1:      mov     fs:[edx].rd_ptr, esi    ; запомним новое значение указателя чтения
                dec     fs:[edx].byte_cntr
                mov     edx, 1                  ; прочитали 1 байт
                pop     esi
                pop     ebx
                ret
RB_BGetAL       ENDP


; --- чтение слова из кольцевого буфера в AX ----------------------------------
;     !! при попытке прочитать больше чем есть - ПРОСТО НИЧЕГО НЕ ЧИТАЕТСЯ  !!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
; выход: ax     - прочитанное слово (если edx = 2)
;        edx    - количество реально прочитанных байт (т.е. 2 или 0)
;
RB_BGetAX       PROC
                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                cmp     fs:[edx].byte_cntr, 2   ; а в буфере найдётся 2 байта ?
                jae     SHORT RB_BGAX_0         ; ДА - дальше
RB_BGAX_Empty:  xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_BGAX_0:      push    ebx
                push    esi
                cld
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение
                lods    BYTE PTR fs:[esi]       ; получили мл. байт из буфера
                mov     ebx, fs:[edx].mem_ptr
                add     ebx, fs:[edx].len       ; верхняя граница используемой памяти + 1
                cmp     esi, ebx                ; вышли за неё ?
                jb      SHORT RB_BGAX_1         ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGAX_1:      xchg    al, ah
                lods    BYTE PTR fs:[esi]       ; получили ст. байт из буфера
                xchg    al, ah                  ; восстановили правильный порядок следования байт
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_BGAX_2         ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGAX_2:      mov     fs:[edx].rd_ptr, esi    ; запомним новое значение указателя чтения
                sub     fs:[edx].byte_cntr, 2
                mov     edx, 2                  ; прочитали 2 байта
                pop     esi
                pop     ebx
                ret
RB_BGetAX       ENDP


; --- чтение двойного слова из кольцевого буфера в EAX ------------------------
;     !! при попытке прочитать больше чем есть - ПРОСТО НИЧЕГО НЕ ЧИТАЕТСЯ  !!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
; выход: eax    - прочитанное двойное слово (если edx = 4)
;        edx    - количество реально прочитанных байт (т.е. 4 или 0)
;
RB_BGetEAX      PROC
                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                cmp     fs:[edx].byte_cntr, 4   ; а в буфере найдётся 4 байта ?
                jae     SHORT RB_BGEAX_0        ; ДА - дальше
RB_BGEAX_Empty: xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_BGEAX_0:     push    ebx
                push    esi
                cld
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение
                lods    BYTE PTR fs:[esi]       ; получили 1-й байт из буфера
                mov     ebx, fs:[edx].mem_ptr
                add     ebx, fs:[edx].len       ; верхняя граница используемой памяти + 1
                cmp     esi, ebx                ; вышли за неё ?
                jb      SHORT RB_BGEAX_1        ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGEAX_1:     ror     eax, 8
                lods    BYTE PTR fs:[esi]       ; получили 2-й байт из буфера
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_BGEAX_2        ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGEAX_2:     ror     eax, 8
                lods    BYTE PTR fs:[esi]       ; получили 3-й байт из буфера
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_BGEAX_3        ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGEAX_3:     ror     eax, 8
                lods    BYTE PTR fs:[esi]       ; получили 4-й байт из буфера
                ror     eax, 8                  ; восстановим правильный порядок следования байт
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_BGEAX_4        ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - ук. чтения в начало используемой памяти
RB_BGEAX_4:     mov     fs:[edx].rd_ptr, esi    ; запомним новое значение указателя чтения
                sub     fs:[edx].byte_cntr, 4
                mov     edx, 4                  ; прочитали 4 байта
                pop     esi
                pop     ebx
                ret
RB_BGetEAX      ENDP

; *** вызова, обслуживающие пакетный режим кольцевого буфера ******************
; --- запись сообщения (пакета) в кольцевой буфер (двойными словами !) --------
;     !!! если буфер БАЙТОВЫЙ - будет БОЛЬШАЯ БЕДА !!!
; вход:  edx    - номер буфера, который собираемся использовать, в es
;        es     - селектор сегмента содержащего используемый буфер
;        ecx    - число записываемых байт
;        ds:esi - указатель на первый записываемый байт
; выход: edx    - 0 - записи не было, 1 - успешная запись
;
RB_MPut         PROC
                or      ecx, ecx                ; \ защита от
                jz      RB_MP_NULL              ; / записи 0 байт
                pushad
                cld

                shl     edx, _RB_STRUC_SHL      ; указатель на управляющую структуру буфера
                mov     ebx, es:[edx].len       ; размер буфера
                mov     edi, ebx
                mov     ebp, es:[edx].mem_ptr   ; НИЖНЯЯ граница используемой буфером памяти
                add     ebx, ebp                ; ВЕРХНЯЯ граница используемой буфером памяти + 1
                sub     edi, es:[edx].byte_cntr ; свободно байт в буфере
                sub     edi, 2                  ; ещё учтём слово длины
                cmp     edi, ecx                ; есть место под ecx новых байт + 2 ?
                jl      RB_MP_Full        ; НЕТ - выйдем с нулём
                mov     edi, es:[edx].wr_ptr    ; указатель на запись
                lodsw                           ; первые 2 байта сообщения
                shl     eax, 16
                mov     ax, cx                  ; слово длины
                stosd                           ; слово длины и первые 2 байта в буфер
                cmp     edi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_MP_0           ; НЕТ -
                mov     edi, ebp                ; ДА - указатель на начало используемой памяти
RB_MP_0:        add     ecx, 2                  ; учтём что надо записать слово длины
                test    ecx, 3                  ; суммарная записываемая длина кратна 4-м ?
                jz      SHORT RB_MP_1           ; ДА -
                add     ecx, 4                  ; НЕТ - для округления вверх
RB_MP_1:        mov     eax, ecx
                and     eax, 0fffffffch         ; на столько байт пополнится буфер
                shr     ecx, 2                  ; столько надо записать двойных слов
                inc     es:[edx].mess_cntr      ; отметим запись сообщения
                add     es:[edx].byte_cntr, eax ; в пакетном режиме буфер пополняется дв. словами
                dec     ecx                     ; одно двойное слово уже записали !!!
                and     ecx, 0ffh                   ;;;; без этого почему-то exeption !?
                jcxz    RB_MP_3                 ; ЗАЩИТА ОТ ДУРАКА
RB_MP_Loop:     movsd
                cmp     edi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_MP_2           ; НЕТ -
                mov     edi, ebp                ; ДА - указатель на начало используемой памяти
RB_MP_2:        loop    RB_MP_Loop
RB_MP_3:        mov     es:[edx].wr_ptr, edi    ; запомним новое положение указателя записи
                popad
                mov     edx, 1                  ; отметим успешную запись
                ret

RB_MP_Full:     inc     es:[edx].of_cntr        ; отметим возможное переполнение буфера
                popad
RB_MP_NULL:     xor     edx, edx                ; отметим переполнение буфера - нет записи
                ret
RB_MPut         ENDP


; ***********************************************
; --- КОПИРОВАНИЕ сообщения из кольцевого буфера (двойными словами !) для отладочной
; печати, структура кольцевого буфера не меняется !
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
;        es:edi - указатель на первый принимаемый байт
; выход: edx    - число байт в прочитанном сообщении
;
RB_DCopy	PROC
                shl     edx, _RB_STRUC_SHL      ; указатель на управляющую структуру буфера
                cmp     fs:[edx].mess_cntr, 0   ; в буфере есть сообщение (для байтового всегда 0)?
                jne     SHORT RB_DC_0           ; ДА - дальше
RB_DC_Empty:    xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_DC_0:        push    eax
                push    ebx
                push    ecx
                push    edi
                push    esi
                push    ebp
                push    fs:[edx].byte_cntr      ;;;
                cld

                mov     ebx, fs:[edx].len       ; размер буфера
                mov     ebp, fs:[edx].mem_ptr   ; НИЖНЯЯ граница используемой буфером памяти
                add     ebx, ebp                ; ВЕРХНЯЯ граница используемой буфером памяти + 1
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение
                lods    DWORD PTR fs:[esi]      ; читаем двойное слово
                mov     ecx, eax
                and     ecx, 0ffffh             ; 2 младших байта - слово длины - выделим
                shr     eax, 16                 ; 2 старших байта - первые байты сообщения
                stosw                           ; отдадим их
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_DC_1           ; НЕТ -
                mov     esi, ebp                ; ДА - указатель на начало используемой памяти
RB_DC_1:        mov     eax, ecx                ; запомним фактическое число байт в сообщении
                add     ecx, 2                  ; в буфере кроме сообщения ещё и слово длины
                test    ecx, 3                  ; суммарное число байт кратно 4-м ?
                jz      SHORT RB_DC_2           ; ДА - и прекрасно
                add     ecx, 4                  ; НЕТ - чтобы округлилось вверх
RB_DC_2:        and     ecx, 0fffffffch         ; на столько байт похудеет буфер
                ;dec     fs:[edx].mess_cntr	; отметим чтение сообщения
                sub     fs:[edx].byte_cntr, ecx ; в пакетном режиме буфер освобождается дв. словами
                shr     ecx, 2                  ; надо прочитать столько двойных слов
                dec     ecx                     ; одно дв. слово уже прочитали !
                jcxz    RB_DC_4                 ; ЗАЩИТА ОТ ДУРАКА
RB_DC_Loop:     movs    DWORD PTR [edi], DWORD PTR fs:[esi]
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_DC_3           ; НЕТ -
                mov     esi, ebp                ; ДА - указатель на начало используемой памяти
RB_DC_3:        loop    RB_DC_Loop
RB_DC_4:        ;mov     fs:[edx].rd_ptr, esi    ; запомним новое положение указателя чтения

                pop	fs:[edx].byte_cntr	;;;

                mov     edx, eax                ; на выходе число байт в сообщении

                pop     ebp
                pop     esi
                pop     edi
                pop     ecx
                pop     ebx
                pop     eax
		ret
RB_DCopy	ENDP


; --- чтение сообщения из кольцевого буфера (двойными словами !) --------------
;     !!! если буфер БАЙТОВЫЙ - на выходе ВСЕГДА 0 !!!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
;        es:edi - указатель на первый принимаемый байт
; выход: edx    - число байт в прочитанном сообщении
;
RB_MGet         PROC
                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                cmp     fs:[edx].mess_cntr, 0   ; в буфере есть сообщение (для байтового всегда 0)?
                jne     SHORT RB_MG_0           ; ДА - дальше
RB_MG_Empty:    xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_MG_0:        push    eax
                push    ebx
                push    ecx
                push    edi
                push    esi
                push    ebp
                cld

                mov     ebx, fs:[edx].len       ; размер буфера
                mov     ebp, fs:[edx].mem_ptr   ; НИЖНЯЯ граница используемой буфером памяти
                add     ebx, ebp                ; ВЕРХНЯЯ граница используемой буфером памяти + 1
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение
                and     esi, 0FFFFh
                lods    DWORD PTR fs:[esi]      ; читаем двойное слово
                mov     ecx, eax
                and     ecx, 0ffffh             ; 2 младших байта - слово длины - выделим
                shr     eax, 16                 ; 2 старших байта - первые байты сообщения
                stosw                           ; отдадим их
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_MG_1           ; НЕТ -
                mov     esi, ebp                ; ДА - указатель на начало используемой памяти
RB_MG_1:        mov     eax, ecx                ; запомним фактическое число байт в сообщении
                add     ecx, 2                  ; в буфере кроме сообщения ещё и слово длины
                test    ecx, 3                  ; суммарное число байт кратно 4-м ?
                jz      SHORT RB_MG_2           ; ДА - и прекрасно
                add     ecx, 4                  ; НЕТ - чтобы округлилось вверх
RB_MG_2:        and     ecx, 0fffffffch         ; на столько байт похудеет буфер
                dec     fs:[edx].mess_cntr      ; отметим чтение сообщения
                sub     fs:[edx].byte_cntr, ecx ; в пакетном режиме буфер освобождается дв. словами
                shr     ecx, 2                  ; надо прочитать столько двойных слов
                dec     ecx                     ; одно дв. слово уже прочитали !
                and     ecx, 0FFh
                jcxz    RB_MG_4                 ; ЗАЩИТА ОТ ДУРАКА
RB_MG_Loop:     movs    DWORD PTR [edi], DWORD PTR fs:[esi]
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_MG_3           ; НЕТ -
                mov     esi, ebp                ; ДА - указатель на начало используемой памяти
RB_MG_3:        loop    RB_MG_Loop
RB_MG_4:        mov     fs:[edx].rd_ptr, esi    ; запомним новое положение указателя чтения
                mov     edx, eax                ; на выходе число байт в сообщении

                pop     ebp
                pop     esi
                pop     edi
                pop     ecx
                pop     ebx
                pop     eax
                ret
RB_MGet         ENDP


; --- чтение сообщения из кольцевого буфера вместе со словом длины ------------
;     !!! если буфер БАЙТОВЫЙ - на выходе ВСЕГДА 0 !!!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
;        es:edi - указатель на первый принимаемый байт
; выход: edx    - число байт в прочитанном сообщении
;
RB_MAllGet      PROC
;                jcxz    RB_MAG_Empty            ; защита от чтения 0 байт !
                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                cmp     fs:[edx].mess_cntr, 0   ; в буфере есть сообщение (для байтового всегда 0)?
                jne     SHORT RB_MAG_0          ; ДА - дальше
RB_MAG_Empty:   xor     edx, edx                ; НЕТ - 0 байт считано и выход
                ret

RB_MAG_0:       push    eax
                push    ebx
                push    ecx
                push    edi
                push    esi
                push    ebp
                cld

                mov     ebx, fs:[edx].len       ; размер буфера
                add     ebx, fs:[edx].mem_ptr   ; ВЕРХНЯЯ граница используемой буфером памяти + 1
                mov     esi, fs:[edx].rd_ptr    ; указатель на чтение

                xor     ecx, ecx
                mov     cx, fs:[esi]            ; получим длину копируемого сообщения
                mov     eax, ecx
                add     ecx, 2                  ; учтём само слово длины
                test    ecx, 3                  ; суммарное число копируемых байт кратно 4-м ?
                jz      SHORT RB_MAG_1          ; НЕТ - ничего делать не надо
                add     ecx, 4                  ; ДА - чтобы округлить
RB_MAG_1:       shr     ecx, 2                  ; число копируемых двойных слов
                mov     ebp, ecx

RB_MAG_Loop:    movs    DWORD PTR [edi], DWORD PTR fs:[esi]
                cmp     esi, ebx                ; вышли за верхнюю границу используемой памяти ?
                jb      SHORT RB_MAG_2          ; НЕТ -
                mov     esi, fs:[edx].mem_ptr   ; ДА - указатель на начало используемой памяти
RB_MAG_2:       loop    RB_MAG_Loop
                mov     fs:[edx].rd_ptr, esi    ; запомним новое положение указателя чтения
                dec     fs:[edx].mess_cntr      ; отметим чтение сообщения
                shl     ebp, 2
                sub     fs:[edx].byte_cntr, ebp ; в пакетном режиме буфер освобождается дв. словами
                mov     edx, eax                ; на выходе число байт в сообщении

                pop     ebp
                pop     esi
                pop     edi
                pop     ecx
                pop     ebx
                pop     eax
                ret
RB_MAllGet      ENDP


; --- удаление сообщения из кольцевого буфера без пересылки данных ------------
;     !!! если буфер БАЙТОВЫЙ - просто НИЧЕГО не происходит !!!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
; выход: edx    - число байт в удалённом сообщении
;
RB_MDel         PROC
                shl     edx, _RB_STRUC_SHL     ; указатель на управляющую структуру буфера
                cmp     fs:[edx].mess_cntr, 0   ; в буфере есть сообщение (для байтового всегда 0)?
                jne     SHORT RB_MD_0           ; ДА - дальше
RB_MD_Empty:    xor     edx, edx                ; НЕТ - 0 байт очищено - то бишь ни хрена
                ret

RB_MD_0:        push    eax
                push    ebx
                mov     ebx, fs:[edx].len       ; размер буфера
                add     ebx, fs:[edx].mem_ptr   ; ВЕРХНЯЯ граница используемой буфером памяти
                mov     eax, fs:[edx].rd_ptr    ; получим указатель чтения
                mov     eax, fs:[eax]           ; по указателю чтения получим слово длины
                and     eax, 0ffffh             ; убьём мусор в старших байтах
                push    eax
                add     eax, 2                  ; учтём слово длины
                test    eax, 3                  ; общее число байт кратно 4-м ?
                jz      SHORT RB_MD_1           ; ДА - и славно
                add     eax, 4                  ; НЕТ - чтобы округлить вверх
RB_MD_1:        and     eax, 0fffch             ; округляем вверх до числа кратного 4-м
                dec     fs:[edx].mess_cntr      ; отметим удаление сообщения
                sub     fs:[edx].byte_cntr, eax ; в пакетном режиме буфер освобождается дв. словами
                add     fs:[edx].rd_ptr, eax    ; двигаем указатель чтения
                cmp     fs:[edx].rd_ptr, ebx    ; вышли за верхнюю границу памяти ?
                jb      SHORT RB_MD_2           ; НЕТ -
                mov     ebx, fs:[edx].len       ; \ на размер буфера
                sub     fs:[edx].rd_ptr, ebx    ; / скорректируем указатель
RB_MD_2:        pop     edx                     ; вернём байт в пакете
                pop     ebx
                pop     eax
                ret
RB_MDel         ENDP


; --- получение длины первого сообщения в пакетном кольцевом буфере -----------
;     !!! если буфер БАЙТОВЫЙ - на выходе ВСЕГДА 0 !!!
; вход:  edx    - номер буфера, который собираемся использовать, в fs
;        fs     - селектор сегмента содержащего используемый буфер
; выход: edx    - длина первого сообщения

RB_MLen         PROC
                shl     edx, _RB_STRUC_SHL
                cmp     fs:[edx].mess_cntr, 0   ; в буфере есть сообщение ?
                jne     SHORT RB_ML_0           ; ДА - дальше
RB_ML_Empty:    xor     edx, edx                ; НЕТ - возвращаем 0
                ret

RB_ML_0:        mov     edx, fs:[edx].rd_ptr    ; указатель чтения
                mov     edx, fs:[edx]           ; указывает на слово длины 1-го сообщения в буфере
                and     edx, 0ffffh             ; старшие 2 байта - мусора
                ret
RB_MLen         ENDP


; *** не очень нужные, просто на всякий случай, вызова ************************
; --- очистка буфера от данных ------------------------------------------------
; вход:  edx    - номер очищаемого буфера
;        fs     - селектор сегмента, содержащего очищаемый буфер
; выход: НЕТ

RB_Clear        PROC
                push    ebx
                push    edx
                shl     edx, _RB_STRUC_SHL
                mov     ebx, fs:[edx].mem_ptr   ; указатель на начало используемой памяти
                mov     fs:[edx].wr_ptr, ebx    ; \ указатели и записи и
                mov     fs:[edx].rd_ptr, ebx    ; / чтения вначало
                xor     ebx, ebx
                mov     fs:[edx].of_cntr, ebx   ; \  обнулим
                mov     fs:[edx].byte_cntr, ebx ;  > все
                mov     fs:[edx].mess_cntr, ebx ; /  счётчики
                pop     edx
                pop     ebx
                ret
RB_Clear        ENDP


; --- чтение счётчика переполнений буфера -------------------------------------
; вход:  edx    - номер буфера из которого читаем счётчик переполнений
;        fs     - селектор сегмента, содержащего интересующий нас буфер
;        CF     - если флаг переноса установлен - очистка счётчика
; выход: edx    - значение счётчика переполнений

RB_OFCnt        PROC
                push    eax
                shl     edx, _RB_STRUC_SHL
                mov     eax, fs:[edx].of_cntr
                jnc     SHORT RB_OF_Exit        ; не чистим счётчик
                mov     fs:[edx].of_cntr, 0     ; чистим !
RB_OF_Exit:     mov     edx, eax
                pop     eax
                ret
RB_OFCnt        ENDP


; --- параметры кольцевого буфера ---------------------------------------------
; вход:  edx    - номер буфера параметрры которого запрашиваем
;        fs     - селектор сегмента, содержащего буфер с очищаемым счётчиком переполнений
; выход: eax    - размер буфера
;        ebx    - аттрибуты буфера
;        ecx    - лежит байт в буфере
;        edx    - лежит сообщений (пакетов) в буфере

RB_Prms         PROC
                shl     edx, _RB_STRUC_SHL
                mov     eax, fs:[edx].len
                mov     ebx, fs:[edx].attr
                mov     ecx, fs:[edx].byte_cntr
                mov     edx, fs:[edx].mess_cntr
                ret
RB_Prms         ENDP


; --- проверка возможности записать в буфер -----------------------------------
; вход:  edx    - номер буфера который проверяем
;        fs     - селектор сегмента, содержащего буфер с очищаемым счётчиком переполнений
;        eax    - количество байт, которое хотим записать
; выход: edx    - 1 буфер полон, 0 запись возможна

RB_IsFull       PROC
                push    esi
                push    ebx
                mov     esi, edx
                shl     esi, _RB_STRUC_SHL
                xor     edx, edx
                mov     ebx, fs:[esi].len
                cmp     ebx, fs:[esi].byte_cntr
                ja      RBIF_Exit
                mov     edx, 1
RBIF_Exit:      pop     ebx
                pop     esi
                ret
RB_IsFull       ENDP


