; ╔════════════════════════════════════════════════════════════════════════════╗
; ║  Файл:         PUMA_Scr.ASM                                                ║
; ║  Программист:  Тоневицкий Ю.Д.                                             ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Использует:   PUMA_Scr.DAT                                                ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Назначение:   Модуль, передающий изменения экрана по ПУМе                 ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Содержит:     Scr_Mark_Diffs - процедура сравнения рабочего экрана с его  ║
; ║                                 копией для обнаружения его изменений       ║
; ║                Scr_Send_Diffs - передача найденных изменений в ПУМу        ║
; ║                @Clear_All_Diffs - макрос очистки буфера изенений           ║
; ║                @Close_Curr_Diff - макрос создающий новую запись в буфере   ║
; ║                                   изменений                                ║
; ║                @Scr_Enabled     -                                          ║
; ║                @Scr_Disabled    -                                          ║
; ╟────────────────────────────────────────────────────────────────────────────╢
; ║  Работа:                                                                   ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ║                                                                            ║
; ╚════════════════════════════════════════════════════════════════════════════╝


; --- поиск изменений экрана, найденные изменения фиксируются в буфере изменений
;     для последующей отсылки в ПУМу
; вход:         fs:[esi] - указатель на начало основного экрана
;               рабочие переменные модуля
; выход:        рабочие переменные модуля [буфер изменений прежде всего]
;
Scr_Mark_Diffs  PROC
                ASSUME  DS:SCREEN_SEG_PUMA
                ; ---
                cmp     bScrEnabled, 0
                je      SMD_Exit
                ; --- пока все ранее найденные изменения не уйдут в ПУМу, новых не ищем
SMD_Count:      cmp     dDiffsCount, 0
                jne     SMD_Exit
                ; --- начальные установки
                @Clear_All_Diffs        ; очищаем буфер отличий
                cld
                push    ds              ; \ сегмент
                pop     es              ; / копии экрана
                xor     ebx, ebx        ; указатель на начало изменённой части экрана
                mov     ecx, 80 * 50    ; в экране 50 строк по 80 символов
                xor     edx, edx        ; длина изменённой части экрана (в парах символ + аттрибут)
                lea     edi, Screen_Copy; указатель на начало копии экрана
                ; --- поиск первого несовпадения
                repe    cmps    WORD PTR fs:[esi], WORD PTR es:[edi]
                jne     SMD_1st_Diff    ; есть несовпадение
                ; --- изменений экрана не обнаружено
                ret                     ; выходим ничего не отправляя
                ; --- отмечаем первое обнаруженное изменение экрана
SMD_1st_Diff:   sub     edi, 2          ; \ возращаем указатели
                sub     esi, 2          ; / на несовпадение
                mov     ebx, esi        ; запоминаем указатель на начало несовпадения
                mov     edx, 2          ; как минимум изменилась одна позиция экрана или её аттрибут
                movs    WORD PTR es:[edi], WORD PTR fs:[esi] ; сравняем копии экранов
                ; --- цикл поиска всех последующих несовпадений
SMD_Loop:       repe    cmps    WORD PTR fs:[esi], WORD PTR es:[edi]
                jecxz   SMD_End
                jne     SMD_Next_Diff   ; очередное несовпадение
                ; --- прошли весь экран
SMD_End:        or      edx, edx        ; есть найденная, но не отмеченная в буфере изменившаяся область экрана
                jz      SMD_Exit        ; НЕТ - просто выходим
                @Close_Curr_Diff        ; закрываем последнее изменение
SMD_Exit:       ret
                ; --- обрабатываем последующие изменения экрана
SMD_Next_Diff:  sub     edi, 2          ; \ возращаем указатели
                sub     esi, 2          ; / на несовпадение
                movs    WORD PTR es:[edi], WORD PTR fs:[esi] ; сравняем копии экранов
                ; --- проверяем есть ли не закрытая областей несовпадения
                or      edx, edx        ; есть незакрытая область изменения экрана
                jz      SMD_New_Diff    ; НЕТ - по любому это новое изменение
                ; --- проверяем размер текущего изменения
                cmp     edx, 80 * 2     ; длина не закрытой области изменения >= длине строки экрана ?
                jae     SMD_Close_Diff  ; ДА - надо закрыть
                ; --- проверяем есть ли смысл отнести новое изменение к текущему
                mov     eax, esi        ;
                sub     eax, ebx        ; от точки предыдущего несовпадения до точки только что обнаруженого несовпадения
                sub     eax, edx        ; а теперь от конца предыдущего несовпадения до начала нового
                cmp     eax, 4 * 2      ; больше четырёх позиций экрана ?
                ja      SMD_Close_Diff  ; ДА - выгоднее закрыть предыдущее изменение и начать новое
                ; --- просто увеличим размер изменённой области
                add     eax, 2          ;
                add     edx, eax        ;
                jmp     SMD_Loop        ; и продолжим
                ; --- считаем что нашли конец изменившейся области экрана
SMD_Close_Diff: @Close_Curr_Diff        ;
                ; --- считаем что нашли очередную изменившуюся область экрана
SMD_New_Diff:   mov     ebx, esi        ; \ её
                sub     ebx, 2          ; / начало
                mov     edx, 2          ; длина пока минимально возможная
                jmp     SMD_Loop        ;
Scr_Mark_Diffs  ENDP

; --- передача изменений, зафиксированных в буфере, в ПУМу --------------------
;     вход/выход - рабочие переменные модуля
;
Scr_Send_Diffs  PROC
                ASSUME  DS:SCREEN_SEG_PUMA
                ; ---
                cmp     bScrEnabled, 0
                je      SSD_Exit
                ; --- пока отправлять нечего - ничего не делаем
                cmp     dDiffsCount, 0          ;
                je      SSD_Exit                ;
                ; --- получаем запись об очередном изменении
SSD_Loop:       mov     ebp, dCurrDiffNum       ;
                cmp     ebp, dDiffsCount        ;
                jae     SSD_Stop                ;
                inc     dCurrDiffNum            ;
                shl     ebp, _DIF_REC_SHIFT     ;
                mov     esi, bufDiffs[ebp].diff_ptr
                mov     ecx, bufDiffs[ebp].diff_len
                ; --- проверим можно ли записать пакет в ПУМу
;                mov     eax, ecx
;                add     eax, 4 + 2 + 2 + 1      ; адрес, группа+команда, смещение, длина
;                mov     edx, 0                  ; во входной буфер СОМ1
;                mov     es, ss:SEG_PUMA         ; все буфера здесь
;                call    RB_IsFull               ; поехали !
;                or      edx, edx                ;
;                jnz     SSD_Exit                ;
                ; --- формирование ПУМовского сообщения об изменении экрана
                lea     edi, messDiff           ; в промежуточный буфер:
                mov     eax, dCtrlAddr          ; \ 1. адрес: от
IF _MSP EQ TRUE
                and     ah, 0f0h
                or      ah, 2
ENDIF
                mov     [edi], eax              ; /    программы в ПУМу
                mov     BYTE PTR [edi + 4], 80h ; 2. группа: всеобщие команды ПУМы
                mov     BYTE PTR [edi + 5], 83h ; 3. команда: символы + аттрибуты
                mov     [edi + 6], si           ; 4. параметр: указатель
                ; ---
                shr     ecx, 1
                mov     [edi + 8], cl           ; 5. параметр: число пар символ + аттрибут
                ; ---
                cld
                push    ds
                pop     es
                add     edi, 9
                rep     movsw
                ; ---
                mov     ecx, bufDiffs[ebp].diff_len
                add     ecx, 4 + 2 + 2 + 1      ; адрес, группа+команда, смещение, длина
                movzx   edx, bCtrlChnl          ; \ во входной буфер канала
                shl     edx, 1                  ; / с которого управляется блок
                lea     esi, messDiff           ; cформированный пакет
                mov     es, ss:SEG_PUMA         ; все буфера здесь
                call    RB_MPut                 ; поехали !
                jmp     SSD_Loop
                ; --- отмечаем, что передали все изменения
SSD_Stop:       @Clear_All_Diffs

SSD_Exit:       ret
Scr_Send_Diffs  ENDP
